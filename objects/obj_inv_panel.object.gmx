<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
    This object should never be instantiated, you need to create specific panels
    with this object as parent, each one representing an inventory type.
    E.g: toolbar panel, chest panel, crafting panel, ...
*/

//initialize generic panel properties
inv = -1; //inventory linked to this panel
slots = -1; //array of slot instances linked to the panel

/*  this flag is used to temporarily disable recipe checking every time a slot is updated,
    for performance purposes */
inventory_changed_callback = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//call cleanup event
event_user(panel_events.cleanup);

//destroy all slot instances
if(is_array(slots)) {
    for(var i=0; i&lt;array_length_1d(slots); i++) {
        with(slots[i]) {
            instance_destroy();
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///cleanup event
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///slot updated event

/*
    This event gets called whenever a slot of the panel gets an update
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///slot right pressed event

/*
    This event is fired when a slot of this panel is right clicked.
    By default, we take half of the items in the slot or release
    one unit of the held item.
    
    Complex inventories like crafting benches or equipment should
    override this event.
*/

//get the affected slots
var slot = other.id;
var mouse_slot = obj_inv_mouse.slots[0];

if(slot.key == mouse_slot.key || slot.item &lt; 0) {
    //same item or slot empty, drop one unit of the one held by the mouse
    var amount = ex_inv_add_slot(inv,mouse_slot.item,1,slot.index);
    ex_inv_remove_slot(obj_inv_mouse.inv,amount,0);
}
else if(mouse_slot.item &lt; 0 &amp;&amp; slot.item &gt;= 0) {
    //mouse has no item, get half of the item units (rounded up) of the slot
    var units = ceil(slot.amount / 2);
    
    var amount = ex_inv_add_slot(obj_inv_mouse.inv,slot.item,units,0);
    ex_inv_remove_slot(inv,units,slot.index);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///slot left pressed event

/*
    By default, when a panel slot is left clicked, the item
    is switched with the one on the mouse, or if the mouse
    is holding the same item, amounts are merged.
    
    Complex inventories like crafting benches or equipment should
    override this event.
*/

//get the affected slots
var slot = other.id;
var mouse_slot = obj_inv_mouse.slots[0];

if(keyboard_check(vk_control)) {
    ex_inv_add(inv,slot.item,1);
}
//make items unique
else if(keyboard_check(vk_shift)) {
    if(slot.item &gt;= 0) {
        //ask the user for a new name for the unique item
        var new_name = get_string("Name your unique item","unique " + slot.item[? "name"]);
        if(new_name == "") {new_name = "unique " + slot.item[? "name"];}
    
        /* 
            if we sicceed at setting it unique, update the name accordingly.
            Note that in this demo the only attribute changing is the name, you'll have to assign a new key 
            differently in your game depending on how you want unique items to stack (see docs for more info).
        */
        if(ex_inv_item_set_unique(inv,slot.index,slot.item[? "base_key"]+"_"+md5_string_unicode(new_name))) {
            slot.item[? "name"] = new_name; 
        }
    }
}
//mouse items and clicked slot item are different, switch
else if(slot.key != mouse_slot.key) {
    ex_inv_switch(inv,slot.index,mouse_slot.inv,mouse_slot.index);
}
//mouse item and clicked slot item are the same, try adding
else {
    var amount = ex_inv_add_slot(inv,mouse_slot.item,mouse_slot.amount,slot.index);
    ex_inv_remove_slot(obj_inv_mouse.inv,amount,0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///inventory changed event

/*
    This event is fired when an inventory gets updated
*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///after create event

/*
    This event is fired after the panel instance has been created
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///call cleanup event

event_user(panel_events.cleanup);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
