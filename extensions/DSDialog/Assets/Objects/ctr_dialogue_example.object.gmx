<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>ctr_dialogue_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create Dialogue Scripts

//Below is an extensive example of the dialouge system, that takes in use all of the features avaliable.
//It is recommended you follow the same pattern when creating dialouge. Below everything you can find
//same code example, with extensive comments that goes through everything and explains what it does.

//Parent Inheritance
event_inherited();

//Branch(0)
scr_set_branch(0);
if !global.condition
{
    scr_dialogue(1, LEFT, obj_actor_1, noone, "Hello World! How are you feeling?");
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I'm not the world, I'm a person, you crazy brah? What ya want?");
}
else
{
    scr_dialogue(noone, LEFT, obj_actor_1, noone, "Hello World! How are you feeling today!?");
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "You again... What ya want crazy person?");
}
scr_choice("More Options:", 0, scr_find_branch(1));
scr_choice("Tell me all your secrets!", noone, scr_find_branch(2));
scr_choice("A branching dialogue system in my game.", 0, scr_find_branch(3));
scr_choice("Leave:", 10);

//Branch (1)
scr_set_branch(1);
scr_set_branch_type(B_C);
scr_choice("Nothing, just exploring my options.", 0, scr_find_branch(4));
scr_choice("WORLD DOMINATION!!!?!", 0, scr_find_branch(5));
//Created Later: scr_choice("Why is Sweetie Bell best pony?", 0, scr_find_branch(9));
scr_choice("Back:", 0, scr_find_branch(0), true);

//Branch (2)
scr_set_branch(2);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Tell me all your secrets!");
scr_set_branch(2, 1);
scr_set_branch_type(B_N);
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Alright, alright! I did it! It was me, I'm sorry!!!");
    scr_dialogue(21, RIGHT, obj_actor_2, noone, "I'm such a Brony. Sweetie Bell is best pony."); //Note the ID
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I've hidden a branch somewhere, can you find it?");
    scr_dialogue(1337, RIGHT, obj_actor_2, noone, "I already told you everything."); //Note the ID
scr_set_branch(2);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Awesome!");

//Branch (3)
scr_set_branch(3);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "A branching dialogue system in my game.");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Is that so? Have you tried DS Dialogue System? I made it myself.");
scr_dialogue(noone, LEFT, obj_actor_1, noone, "I'm actually trying it right now!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Wow really? That is so meta.");
scr_dialogue(noone, LEFT, obj_actor_1, noone, "I know. I'm wondering how far can this system branch?");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "As far as you want. It's fully feature rich and allows for so much customizability.");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Should I tell you more, or do you want to go back to the hub?");
scr_choice("Tell me more!", 0, scr_find_branch(6));
scr_choice("Go Back to Hub:", 0, scr_find_branch(0), true);

//Branch (4)
scr_set_branch(4);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Nothing, just exploring my options.");
    scr_set_branch(4, 1);
    scr_set_branch_type(B_RO);
    scr_set_branch(4, 1, 0)
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Oh, have you tried a random once branch then?");
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "What is that?");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "It's a type of branch that choosen an index at random.");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Once that index have been played, it is then excluded from future random calls.");
    scr_set_branch(4, 1, 1)
    scr_set_branch_type(B_RN);
        scr_set_branch(4, 1, 1, 0)
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Have you tried the random nested branch?");
            scr_dialogue(noone, LEFT, obj_actor_1, noone, "Maybe, what is it?");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "It's a type of branch that choosen an index at random.");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Once that index have been played, it is then excluded from future random calls.");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "But compared to the random once, which excludes an index every time it's played, the random once branch only is only excluded from random rotation once all it's indexes have been played.");
        scr_set_branch(4, 1, 1, 1)
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I presume you tried the sequence branch?");
            scr_dialogue(noone, LEFT, obj_actor_1, noone, "Most likely, could you tell me about it anyway?");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "It's basically the default branch type. It plays dialogue sequentially until there is no more left until it ends.");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "There also exists a branch of the type next. This does the same, except it doesn't keep playing, it just stops after one go, but remembers the poisition.");
    scr_set_branch(4, 1);
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Well, have fun with that!");
scr_set_branch(4);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Sounds radical!");
    
    
//Branch (5)
scr_set_branch(5);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "WORLD DOMINATION!!!?!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Guess that explains hello world?... wait what?");
scr_set_branch(5, 2);
scr_set_branch_type(B_R);
    scr_dialogue(noone, LEFT, obj_actor_1, noone, "Oh, nvm me it's all random.");
    scr_dialogue(noone, LEFT, obj_actor_1, noone, "Sh!t son, it's all random.");
    scr_set_branch(5, 2, 2);
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "I know, so random right?");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Yeah, totally is. But isn't it cool how you can expand further upon random, by using nested branches?");
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "Yeah the possibilties are like endless. If only there was this one branch type that did what I wanted...");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Well you can create custom branch types if you desire. The system is fully extendable!");
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "Really? That sounds awesome.");
scr_set_branch(5);
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I know it is.");

//Branch (6)
scr_set_branch(6);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Tell me more!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "The dialogue system even allows you to export the scripts aswell as save and load the entire tree!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Do you want me to export the entire tree to a textfile?");
scr_choice("Yes!", 123, scr_find_branch(7));
scr_choice("No...", 0, scr_find_branch(8));

//Branch (7)
scr_set_branch(7);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Yes!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I just did! Check in the appdata game folder for a file named: Dialogue_Export_Example");

//Branch (8)
scr_set_branch(8);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "No...");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Fine then, I wont!");

//Branch (9)
scr_set_branch(9);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Why is Sweetie Bell best pony?");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Cuz amg dem voice cracks!");

//Starts the Dialogue Tree.
scr_dialogue_start(tree);






//
// Code walkthrough with extensive comments:
/* &lt;- Delete this line for better readbility.


//    We start off with this little line of code. It makes sure that we a few needed variables such as the tree.

//Parent Inheritance
event_inherited();

//    In order to even begin with creating dialogue you must first give the controller a branch where it should create our dialogue.
//    This is done by the following script. It sets our current branch to the one at the given index. In this case 0.
//    This index indicates the location the branch is stored. This branch is stored in the tree at index 0, which means it's the first branch.
//    You can create additional nested branches by adding addtional arguments, as can seen in later example down below.
//    This means that scr_set_branch(0, 1) will set the initial branch to index 0 on the tree, and the next branch to index 1 on the 0.
    
//    If you are confused about any of the scripts that will be used, refer to them for additional documentation.

//Branch(0)
scr_set_branch(0);

//    Once you have set your branch, you can start creating dialogue. Here you can even, as shown in the example below, check for conditions
//    as you would with any other code. This could be useful in example, to only play a certain dialogue if you have completed the quest,
//    or in this case, if you have talked to them already. 
    
//    In order to create dialogue, simply use the scr_dialogue(id, location, actor, sound, text). If you desire less or more arguments
//    you can customize these scripts to your desire. Note: That for location a MACRO is used. Make sure to check Macros for their uses.

if !global.condition
{
    scr_dialogue(1, LEFT, obj_actor_1, noone, "Hello World! How are you feeling?");
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I'm not the world, I'm a person, you crazy brah? What ya want?");
}
else
{
    scr_dialogue(noone, LEFT, obj_actor_1, noone, "Hello World! How are you feeling today!?");
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "You again... What ya want crazy person?");
}

//    Once you have created adequate amount of dialogue, you can now start creating choices. This can be done by using the script:
//    scr_choice(text, id, [next], [direct]). Note: that this script takes 2 optional arguments, next and direct. These are used to
//    make the choice interactive, and causes them to go the a different branch. When you use these, it is useful to also use the script
//    scr_find_branch. This works similar to the scr_set_branch, except it returns the branch found instead of setting it, allowing it to be
//    used for much cleaner code, as shown below.
    
//    Note: When choices are created they automatically are created in a type of branch called "Choice Branch". This is a branch
//    that contains only choices, and causes them to be created once run. There are are ton of different branch types you can use.
//    I will try to create an example of each one in this code, so you can see how they work.
    
//    The default branch type is a Sequence Branch. This will play dialogue sequentially until it ends.

scr_choice("More Options:", 0, scr_find_branch(1));
scr_choice("Tell me all your secrets!", noone, scr_find_branch(2));
scr_choice("A branching dialogue system in my game.", 0, scr_find_branch(3));
scr_choice("Leave:", 10);

//    You might have noticed that you can only have up to four choices at a time. This is done for GUI reasons, but can be altered in the code.
//    However, if you wish for more branches, you can create a custom choice branch and have one of the choices lead to that. This is done in 
//    the following code.
    
//    When changing a branch type, you can use the script scr_set_branch_type(type), to change the type of current branch. I've used a few macros
//    to make remembering the values easier. Refer to the Macros or Game Information for some more information.


//Branch (1)
scr_set_branch(1);
scr_set_branch_type(B_C);
scr_choice("Nothing, just exploring my options.", 0, scr_find_branch(4));
scr_choice("WORLD DOMINATION!!!?!", 0, scr_find_branch(5));
//Created Later: scr_choice("Why is Sweetie Bell best pony?", 0, scr_find_branch(9));
scr_choice("Back:", 0, scr_find_branch(0), true); //Note: Direct set to true, to skip ahead to choices of branch.

//    As said before, you can create nested branches within other branches. This is done below in the following example. We create a Next Branch nested
//    in index 1 of the Sequence Branch in index 2 of the tree. The sequence branch will play the initial dialogue, then when next index is played, it
//    finds that it is a branch, so that branch's code is run instead. The next branch only plays 1 dialogue and then ends, but remembers poistion for next call.
//    When that branch ends, we go back the initial branch and continue with the code there.
    
//    This allows for an effect similar to this:
    
//    First Time: 
//    Tell me all your secrets!
//    Alright, alright! I did it! It was me, I'm sorry!!!
//    Awesome!
    
//    Second Time:
//    Tell me all your secrets!
//    I'm such a Brony. Sweetie Bell is best pony.
//    Awesome!


//Branch (2)
scr_set_branch(2);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Tell me all your secrets!");
scr_set_branch(2, 1);
scr_set_branch_type(B_N);
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Alright, alright! I did it! It was me, I'm sorry!!!");
    scr_dialogue(21, RIGHT, obj_actor_2, noone, "I'm such a Brony. Sweetie Bell is best pony."); //Note the ID
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I've hidden a branch somewhere, can you find it?");
    scr_dialogue(1337, RIGHT, obj_actor_2, noone, "I already told you everything."); //Note the ID
scr_set_branch(2);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Awesome!");

//    You can create up to 14 nested branches as that is the maximum argument count. I would however recommend you keep it simple for the sake of insanity.
//    Note in the above code, we have given some of the dialogue an ID. This is a unique number returned to the controller once the dialogue is played.
//    We can then check for this in User_Defined_1 event, and create custom code the handle actions. This could for for example, achivements, secrets uncoverd,
//    new choices open or anything you desire!
    
//    You can even manipulate the system by using manipulation scripts such as scr_branch_change, to cause a branch switch, prematurely.
//    The possibilties are endless!
    
//    Both dialogue and choices return these ids. Branches however, doesn't tell when they are played, but they do say when they end!
//    This is important, because by default, when a branch ends, it will stop the dialogue system. Not end it, but stop it, meaning it can be resumed later.
//    You can however in the user_defined_0 event, detect when branches end, either specific or in general, and write code to change this behaviour.
    
//    This is done if our code example here, which changed the default ending behaviour to cause a return to our initial choices, a so called "Hub".  

//Branch (3)
scr_set_branch(3);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "A branching dialogue system in my game.");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Is that so? Have you tried DS Dialogue System? I made it myself.");
scr_dialogue(noone, LEFT, obj_actor_1, noone, "I'm auctelly trying it right now!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Wow really? That is so meta.");
scr_dialogue(noone, LEFT, obj_actor_1, noone, "I know. I'm wondering how far can this system branch?");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "As far as you want. It's fully feature rich and allows for so much customizability.");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Should I tell you more, or do you want to go back to the hub?");
scr_choice("Tell me more!", 0, scr_find_branch(6));
scr_choice("Go Back to Hub:", 0, scr_find_branch(0), true);

//    There are various different branch types that you can use to customize how you want the dialogue to play out.
//    Below is tried an extensive example of a bunch of nested types.
    
//    It takes use of Random Once branches, a branch that choosen an index to play at random and marks it as played.
//    That index is then excluded from future random calls, until all indexes have been played and it resets.
    
//    If you want an exception to this behaviour, and want to store a nested random branch within a random once branch
//    and only have that excluded once all it's indexes have been played, allow for extensive customizabiltiy on the
//    avaliable random branches, you can use the Random Nested branch, which does this exact thing.
    
//    These are all a bit complicated and rare situations however, but can occur. Normally the default Sequence Branch
//    will suffice for most dialogue system needs.
    
//    If you are ever in need a custom branch type, let me know and I can create some for you. Alternatively you can
//    create your own also. Simple update the script scr_set_branch_type with your new branch and it's associated branch
//    code, to allow for custom behaviour branches.

//Branch (4)
scr_set_branch(4);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Nothing, just exploring my options.");
    scr_set_branch(4, 1);
    scr_set_branch_type(B_RO);
    scr_set_branch(4, 1, 0)
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Oh, have you tried a random once branch then?");
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "What is that?");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "It's a type of branch that choosen an index at random.");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Once that index have been played, it is then excluded from future random calls.");
    scr_set_branch(4, 1, 1)
    scr_set_branch_type(B_RN);
        scr_set_branch(4, 1, 1, 0)
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Have you tried the random nested branch?");
            scr_dialogue(noone, LEFT, obj_actor_1, noone, "Maybe, what is it?");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "It's a type of branch that choosen an index at random.");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Once that index have been played, it is then excluded from future random calls.");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "But compared to the random once, which excludes an index every time it's played, the random once branch only is only excluded from random rotation once all it's indexes have been played.");
        scr_set_branch(4, 1, 1, 1)
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I presume you tried the sequence branch?");
            scr_dialogue(noone, LEFT, obj_actor_1, noone, "Most likely, could you tell me about it anyway?");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "It's basically the default branch type. It plays dialogue sequentially until there is no more left until it ends.");
            scr_dialogue(noone, RIGHT, obj_actor_2, noone, "There also exists a branch of the type next. This does the same, except it doesn't keep playing, it just stops after one go, but remembers the poisition.");
    scr_set_branch(4, 1);
    scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Well, have fun with that!");
scr_set_branch(4);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Sounds radical!");
    
    
//Branch (5)
scr_set_branch(5);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "WORLD DOMINATION!!!?!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Guess that explains hello world?... wait what?");
scr_set_branch(5, 2);
scr_set_branch_type(B_R);
    scr_dialogue(noone, LEFT, obj_actor_1, noone, "Oh, nvm me it's all random.");
    scr_dialogue(noone, LEFT, obj_actor_1, noone, "Sh!t son, it's all random.");
    scr_set_branch(5, 2, 2);
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "I know, so random right?");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Yeah, totally is. But isn't it cool how you can expand further upon random, by using nested branches?");
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "Yeah the possibilties are like endless. If only there was this one branch type that did what I wanted...");
        scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Well you can create custom branch types if you desire. The system is fully extendable!");
        scr_dialogue(noone, LEFT, obj_actor_1, noone, "Really? That sounds awesome.");
scr_set_branch(5);
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I know it is.");

//Branch (6)
scr_set_branch(6);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Tell me more!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "The dialogue system even allows you to export the scripts aswell as save and load the entire tree!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Do you want me to export the entire tree to a textfile?");
scr_choice("Yes!", 123, scr_find_branch(7));
scr_choice("No...", 0, scr_find_branch(8));

//Branch (7)
scr_set_branch(7);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Yes!");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "I just did! Check in the appdata game folder for a file named: Dialogue_Export_Example");

//Branch (8)
scr_set_branch(8);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "No...");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Fine then, I wont!");

//Branch (9)
scr_set_branch(9);
scr_dialogue(noone, LEFT, obj_actor_1, noone, "Why is Sweetie Bell best pony?");
scr_dialogue(noone, RIGHT, obj_actor_2, noone, "Cuz amg dem voice cracks!");


//Starts the Dialogue Tree.
scr_dialogue_start(tree);

/*
    When you are content with your dialogue system, you can start it immedieatly or at anytime when you desire,
    This can be useful if you don't wanna create the dialogue the same time it's played, or want other objects
    to be able to start the dialogue.
    
    This allows for the system to remember variables and such from interactions with it, and makes sure you
    don't have the recreate all the objects everytime.
    
    There are additional scripts that allow you for even more control over the dialogue tree.
    Below can be seen a few of them, that all allows for various interaction with the system.

    //Dialogue Stop
    scr_dialogue_stop(tree);
    
    //Dialogue End
    scr_dialogue_end(tree);
    
    //Dialogue Reset
    scr_dialogue_default(tree);
    
    //Saves Tree
    scr_dialogue_save("Save", tree);
    
    //Loads Tree
    tree = scr_dialogue_load("Save", tree);
    
    //Exports Tree
    scr_dialogue_export("Example_Dialogue_System");
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Choosen Choices

/*  
    Once a choice is choosen, it runs this event on the controller, to allow the user to
    customize what happens next. Use the variable choice to reference the object choosen.
*/

//Dialogue Export Choosen Yes
if choice.c_id = 123
{
    //Exports dialogue tree.
    scr_dialogue_export("Dialogue_Export_Example");
}

//Dialogue Ends.
if choice.c_id = 10
{
    //Unpause interactable.
    with obj_startdialogue
    {
        paused = false;
    }
    
    //Delayed destruction alarm to avoid
    //call-stack errors from running code.
    alarm[0] = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Played Dialogue.

/*  
    Once a dialogue is played, it runs this event on the controller, to allow the user to
    customize what happens next. Use the variable dialogue to reference the object played.
*/

//Played initial dialogue.
if dialogue.d_id = 1
{
    //Updates condition.
    global.condition = true;
}

//Sweetie Bell Choice Unlocked
if dialogue.d_id = 21
{
    //Sets choice branch.
    scr_set_branch(1);
    //var branch = scr_find_branch(1);
    
    //Creates new Choice.
    scr_choice("Why is Sweetie Bell best pony?", 0, scr_find_branch(9));
    
    //Swaps index with "Back:" choice.
    //Note: use self.branch to avoid conflict with var branch.
    array_swap_index(self.branch.list, 2, 3);
    
    //Updates nbr variables on swapped choices.
    self.branch.list[2].nbr = 2;
    self.branch.list[3].nbr = 3;
}

//Told you everything, repeat
if dialogue.d_id = 1337
{
    //Changes current of branch to told you eveything, for repeat of that only.
    var branch = scr_find_branch(2, 1);
    branch.current = 3;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Branch Endings.

/*  
    Once a branch ends, it runs this event on the controller, to allow the user to
    customize what happens next. Refer to documentation or individual branching scripts
    for behavior on how branches default handles ending. Use tree.branch to reference ending branch.
*/

//Awesome, return to hub.
if tree.branch = scr_find_branch(2)
{
    //Causes branch change to hub choice branch to create choices instantly.
    //Remember to use optional argument interupt, or tree will stop dialogue.
    //Note: Choices automatically created their own choice branch. Hence (0, 2) and not (0).
    scr_branch_change(scr_find_branch(0, 2), true);
}

//
//General Branch Ending:
//

//Forces branch change back to hub.
//Note code above bit unnessecary with this, though there for example sake.
scr_branch_change(scr_find_branch(0, 2), true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
